/*! Capacitor: https://capacitorjs.com/ - MIT License */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const legacyRegisterWebPlugin = (cap, webPlugin) => {
    var _a;
    const config = webPlugin.config;
    const Plugins = cap.Plugins;
    if (!config || !config.name) {
        // TODO: add link to upgrade guide
        throw new Error(`Capacitor WebPlugin is using the deprecated "registerWebPlugin()" function, but without the config. Please use "registerPlugin()" instead to register this web plugin."`);
    }
    // TODO: add link to upgrade guide
    console.warn(`Capacitor plugin "${config.name}" is using the deprecated "registerWebPlugin()" function`);
    if (!Plugins[config.name] || ((_a = config === null || config === void 0 ? void 0 : config.platforms) === null || _a === void 0 ? void 0 : _a.includes(cap.getPlatform()))) {
        // Add the web plugin into the plugins registry if there already isn't
        // an existing one. If it doesn't already exist, that means
        // there's no existing native implementation for it.
        // - OR -
        // If we already have a plugin registered (meaning it was defined in the native layer),
        // then we should only overwrite it if the corresponding web plugin activates on
        // a certain platform. For example: Geolocation uses the WebPlugin on Android but not iOS
        Plugins[config.name] = webPlugin;
    }
};

const BRIDGED_CONSOLE_METHODS = [
    'debug',
    'error',
    'info',
    'log',
    'trace',
    'warn',
];
const initLogger = (win, cap) => {
    // patch window.console on iOS and store original console fns
    const isIos = cap.getPlatform() === 'ios';
    const originalConsole = Object.assign({}, win.console);
    if (win.console && isIos) {
        for (const logfn of BRIDGED_CONSOLE_METHODS) {
            win.console[logfn] = (...args) => {
                const msgs = [...args];
                originalConsole[logfn](...msgs);
                try {
                    cap.toNative('Console', 'log', {
                        level: logfn,
                        message: msgs.map(serializeConsoleMessage).join(' '),
                    });
                }
                catch (e) {
                    // error converting/posting console messages
                    originalConsole.error(e);
                }
            };
        }
    }
    cap.logToNative = createLogToNative(win.console);
    cap.logFromNative = createLogFromNative(win.console);
};
const serializeConsoleMessage = (msg) => {
    if (typeof msg === 'object') {
        try {
            msg = JSON.stringify(msg);
        }
        catch (e) {
            // ignore
        }
    }
    return String(msg);
};
const isFullConsole = (c) => {
    if (!c) {
        return false;
    }
    return (typeof c.groupCollapsed === 'function' ||
        typeof c.groupEnd === 'function' ||
        typeof c.dir === 'function');
};
const createLogToNative = (c) => (call) => {
    if (isFullConsole(c)) {
        c.groupCollapsed('%cnative %c' +
            call.pluginId +
            '.' +
            call.methodName +
            ' (#' +
            call.callbackId +
            ')', 'font-weight: lighter; color: gray', 'font-weight: bold; color: #000');
        c.dir(call);
        c.groupEnd();
    }
    else {
        c.log('LOG TO NATIVE: ', call);
    }
};
const createLogFromNative = (c) => (result) => {
    if (isFullConsole(c)) {
        const success = result.success === true;
        const tagStyles = success
            ? 'font-style: italic; font-weight: lighter; color: gray'
            : 'font-style: italic; font-weight: lighter; color: red';
        c.groupCollapsed('%cresult %c' +
            result.pluginId +
            '.' +
            result.methodName +
            ' (#' +
            result.callbackId +
            ')', tagStyles, 'font-style: italic; font-weight: bold; color: #444');
        if (result.success === false) {
            c.error(result.error);
        }
        else {
            c.dir(result.data);
        }
        c.groupEnd();
    }
    else {
        if (result.success === false) {
            c.error('LOG FROM NATIVE', result.error);
        }
        else {
            c.log('LOG FROM NATIVE', result.data);
        }
    }
};

const convertFileSrcServerUrl = (webviewServerUrl, filePath) => {
    if (typeof filePath === 'string') {
        if (filePath.startsWith('/')) {
            return webviewServerUrl + '/_capacitor_file_' + filePath;
        }
        if (filePath.startsWith('file://')) {
            return (webviewServerUrl + filePath.replace('file://', '/_capacitor_file_'));
        }
        if (filePath.startsWith('content://')) {
            return (webviewServerUrl + filePath.replace('content:/', '/_capacitor_content_'));
        }
    }
    return filePath;
};
(function (ExceptionCode) {
    /**
     * API is not implemented.
     *
     * This usually means the API can't be used because it is not implemented for
     * the current platform.
     */
    ExceptionCode["Unimplemented"] = "UNIMPLEMENTED";
    /**
     * API is not available.
     *
     * This means the API can't be used right now because:
     *   - it is currently missing a prerequisite, such as network connectivity
     *   - it requires a particular platform or browser version
     */
    ExceptionCode["Unavailable"] = "UNAVAILABLE";
})(exports.ExceptionCode || (exports.ExceptionCode = {}));
class CapacitorException extends Error {
    constructor(message, code) {
        super(message);
        this.message = message;
        this.code = code;
    }
}

const initBridge = (win, cap) => {
    var _a, _b;
    // keep a collection of callbacks for native response data
    const callbacks = new Map();
    // Counter of callback ids, randomized to avoid
    // any issues during reloads if a call comes back with
    // an existing callback id from an old session
    let callbackIdCount = Math.floor(Math.random() * 134217728);
    let postToNative = null;
    // create the postToNative() fn if needed
    if (win.androidBridge) {
        // android platform
        postToNative = (data) => {
            var _a;
            try {
                win.androidBridge.postMessage(JSON.stringify(data));
            }
            catch (e) {
                (_a = win === null || win === void 0 ? void 0 : win.console) === null || _a === void 0 ? void 0 : _a.error(e);
            }
        };
    }
    else if ((_b = (_a = win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        // ios platform
        postToNative = (data) => {
            var _a;
            try {
                data.type = 'message';
                win.webkit.messageHandlers.bridge.postMessage(data);
            }
            catch (e) {
                (_a = win === null || win === void 0 ? void 0 : win.console) === null || _a === void 0 ? void 0 : _a.error(e);
            }
        };
    }
    cap.handleWindowError = (msg, url, lineNo, columnNo, err) => {
        const str = msg.toLowerCase();
        if (str.indexOf('script error') > -1) ;
        else {
            const errObj = {
                type: 'js.error',
                error: {
                    message: msg,
                    url: url,
                    line: lineNo,
                    col: columnNo,
                    errorObject: JSON.stringify(err),
                },
            };
            if (err !== null) {
                cap.handleError(err);
            }
            if (postToNative) {
                postToNative(errObj);
            }
        }
        return false;
    };
    if (cap.DEBUG) {
        window.onerror = cap.handleWindowError;
    }
    initLogger(win, cap);
    /**
     * Send a plugin method call to the native layer
     */
    cap.toNative = (pluginName, methodName, options, storedCallback) => {
        var _a, _b;
        try {
            if (typeof postToNative === 'function') {
                let callbackId = '-1';
                if (storedCallback &&
                    (typeof storedCallback.callback === 'function' ||
                        typeof storedCallback.resolve === 'function')) {
                    // store the call for later lookup
                    callbackId = String(++callbackIdCount);
                    callbacks.set(callbackId, storedCallback);
                }
                const callData = {
                    callbackId: callbackId,
                    pluginId: pluginName,
                    methodName: methodName,
                    options: options || {},
                };
                if (cap.DEBUG && pluginName !== 'Console') {
                    cap.logToNative(callData);
                }
                // post the call data to native
                postToNative(callData);
                return callbackId;
            }
            else {
                (_a = win === null || win === void 0 ? void 0 : win.console) === null || _a === void 0 ? void 0 : _a.warn(`implementation unavailable for: ${pluginName}`);
            }
        }
        catch (e) {
            (_b = win === null || win === void 0 ? void 0 : win.console) === null || _b === void 0 ? void 0 : _b.error(e);
        }
        return null;
    };
    /**
     * Process a response from the native layer.
     */
    cap.fromNative = (result) => {
        var _a, _b;
        if (cap.DEBUG && result.pluginId !== 'Console') {
            cap.logFromNative(result);
        }
        // get the stored call, if it exists
        try {
            const storedCall = callbacks.get(result.callbackId);
            if (storedCall) {
                // looks like we've got a stored call
                if (result.error) {
                    // ensure stacktraces by copying error properties to an Error
                    result.error = Object.keys(result.error).reduce((err, key) => {
                        err[key] = result.error[key];
                        return err;
                    }, new cap.Exception(''));
                }
                if (typeof storedCall.callback === 'function') {
                    // callback
                    if (result.success) {
                        storedCall.callback(result.data);
                    }
                    else {
                        storedCall.callback(null, result.error);
                    }
                }
                else if (typeof storedCall.resolve === 'function') {
                    // promise
                    if (result.success) {
                        storedCall.resolve(result.data);
                    }
                    else {
                        storedCall.reject(result.error);
                    }
                    // no need to keep this stored callback
                    // around for a one time resolve promise
                    callbacks.delete(result.callbackId);
                }
            }
            else if (!result.success && result.error) {
                // no stored callback, but if there was an error let's log it
                (_a = win === null || win === void 0 ? void 0 : win.console) === null || _a === void 0 ? void 0 : _a.warn(result.error);
            }
            if (result.save === false) {
                callbacks.delete(result.callbackId);
            }
        }
        catch (e) {
            (_b = win === null || win === void 0 ? void 0 : win.console) === null || _b === void 0 ? void 0 : _b.error(e);
        }
        // always delete to prevent memory leaks
        // overkill but we're not sure what apps will do with this data
        delete result.data;
        delete result.error;
    };
    if (typeof postToNative === 'function') {
        // toNative bridge found
        cap.nativeCallback = (pluginName, methodName, options, callback) => {
            if (typeof options === 'function') {
                callback = options;
                options = null;
            }
            return cap.toNative(pluginName, methodName, options, {
                callback: callback,
            });
        };
        cap.nativePromise = (pluginName, methodName, options) => {
            return new Promise((resolve, reject) => {
                cap.toNative(pluginName, methodName, options, {
                    resolve: resolve,
                    reject: reject,
                });
            });
        };
    }
    else {
        // no native bridge created
        cap.nativeCallback = () => {
            throw new CapacitorException(`nativeCallback() not implemented`, exports.ExceptionCode.Unimplemented);
        };
        cap.nativePromise = () => Promise.reject(new CapacitorException(`nativePromise() not implemented`, exports.ExceptionCode.Unimplemented));
    }
};
const getPlatformId = (win) => {
    var _a, _b;
    if (win.androidBridge) {
        return 'android';
    }
    if ((_b = (_a = win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge) {
        return 'ios';
    }
    return 'web';
};

const initEvents = (win, cap) => {
    const doc = win.document;
    const cordova = win.cordova;
    cap.addListener = (pluginName, eventName, callback) => {
        const callbackId = cap.nativeCallback(pluginName, 'addListener', {
            eventName: eventName,
        }, callback);
        return {
            remove: () => {
                var _a;
                (_a = win === null || win === void 0 ? void 0 : win.console) === null || _a === void 0 ? void 0 : _a.debug('Removing listener', pluginName, eventName);
                cap.removeListener(pluginName, callbackId, eventName, callback);
            },
        };
    };
    cap.removeListener = (pluginName, callbackId, eventName, callback) => {
        cap.nativeCallback(pluginName, 'removeListener', {
            callbackId: callbackId,
            eventName: eventName,
        }, callback);
    };
    cap.createEvent = (eventName, eventData) => {
        if (doc) {
            const ev = doc.createEvent('Events');
            ev.initEvent(eventName, false, false);
            if (eventData && typeof eventData === 'object') {
                for (const i in eventData) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (eventData.hasOwnProperty(i)) {
                        ev[i] = eventData[i];
                    }
                }
            }
            return ev;
        }
        return null;
    };
    cap.triggerEvent = (eventName, target, eventData) => {
        eventData = eventData || {};
        const ev = cap.createEvent(eventName, eventData);
        if (ev) {
            if (target === 'document') {
                if (cordova === null || cordova === void 0 ? void 0 : cordova.fireDocumentEvent) {
                    cordova.fireDocumentEvent(eventName, eventData);
                    return true;
                }
                else if (doc === null || doc === void 0 ? void 0 : doc.dispatchEvent) {
                    return doc.dispatchEvent(ev);
                }
            }
            else if (target === 'window' && win.dispatchEvent) {
                return win.dispatchEvent(ev);
            }
            else if (doc === null || doc === void 0 ? void 0 : doc.querySelector) {
                const targetEl = doc.querySelector(target);
                if (targetEl) {
                    return targetEl.dispatchEvent(ev);
                }
            }
        }
        return false;
    };
};

const initLegacyHandlers = (win, cap) => {
    // define cordova if it's not there already
    win.cordova = win.cordova || {};
    const doc = win.document;
    const nav = win.navigator;
    if (nav) {
        nav.app = nav.app || {};
        nav.app.exitApp = () => {
            cap.nativeCallback('App', 'exitApp', {});
        };
    }
    if (doc) {
        const docAddEventListener = doc.addEventListener;
        doc.addEventListener = (...args) => {
            const eventName = args[0];
            const handler = args[1];
            if (eventName === 'deviceready' && handler) {
                Promise.resolve().then(handler);
            }
            else if (eventName === 'backbutton' && cap.Plugins.App) {
                // Add a dummy listener so Capacitor doesn't do the default
                // back button action
                cap.Plugins.App.addListener('backButton', () => {
                    /**/
                });
            }
            return docAddEventListener.apply(doc, args);
        };
    }
    // deprecated in v3, remove from v4
    cap.platform = cap.getPlatform();
    cap.isNative = cap.isNativePlatform();
};

const initVendor = (win, cap) => {
    const Ionic = (win.Ionic = win.Ionic || {});
    const IonicWebView = (Ionic.WebView = Ionic.WebView || {});
    const Plugins = cap.Plugins;
    IonicWebView.getServerBasePath = (callback) => {
        var _a;
        (_a = Plugins === null || Plugins === void 0 ? void 0 : Plugins.WebView) === null || _a === void 0 ? void 0 : _a.getServerBasePath().then(result => {
            callback(result.path);
        });
    };
    IonicWebView.setServerBasePath = (path) => {
        var _a;
        (_a = Plugins === null || Plugins === void 0 ? void 0 : Plugins.WebView) === null || _a === void 0 ? void 0 : _a.setServerBasePath({ path });
    };
    IonicWebView.persistServerBasePath = () => {
        var _a;
        (_a = Plugins === null || Plugins === void 0 ? void 0 : Plugins.WebView) === null || _a === void 0 ? void 0 : _a.persistServerBasePath();
    };
    IonicWebView.convertFileSrc = (url) => cap.convertFileSrc(url);
};

const createCapacitor = (win) => {
    const cap = win.Capacitor || {};
    const Plugins = (cap.Plugins = cap.Plugins || {});
    const webviewServerUrl = typeof win.WEBVIEW_SERVER_URL === 'string' ? win.WEBVIEW_SERVER_URL : '';
    const getPlatform = () => getPlatformId(win);
    const isNativePlatform = () => getPlatformId(win) !== 'web';
    const isPluginAvailable = (pluginName) => Object.prototype.hasOwnProperty.call(Plugins, pluginName);
    const convertFileSrc = (filePath) => convertFileSrcServerUrl(webviewServerUrl, filePath);
    const logJs = (msg, level) => {
        switch (level) {
            case 'error':
                win.console.error(msg);
                break;
            case 'warn':
                win.console.warn(msg);
                break;
            case 'info':
                win.console.info(msg);
                break;
            default:
                win.console.log(msg);
        }
    };
    const handleError = (err) => win.console.error(err);
    const pluginMethodNoop = (_target, prop, pluginName) => {
        return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
    };
    // ensure we do not double proxy the same plugin
    const registeredPlugins = new Map();
    const registerPlugin = (pluginName, impls = {}) => {
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
            return registeredPlugin;
        }
        const nativePluginImpl = Plugins[pluginName];
        if (nativePluginImpl) {
            // the native implementation is already on the global
            // return a proxy that'll also handle any missing methods
            // convert the Capacitor.Plugins.PLUGIN into a proxy and return it
            const nativePluginProxy = (Plugins[pluginName] = new Proxy({}, {
                get(_, prop) {
                    const func = Reflect.get(nativePluginImpl, prop);
                    if (typeof func === 'function') {
                        // call the plugin method, Plugin.method(args)
                        // platform implementation already ready to go
                        return func;
                    }
                    // https://github.com/facebook/react/issues/20030
                    if (prop === '$$typeof') {
                        return undefined;
                    }
                    throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${getPlatform()}`, exports.ExceptionCode.Unimplemented);
                },
            }));
            registeredPlugins.set(pluginName, nativePluginProxy);
            return nativePluginProxy;
        }
        let loadedImpl = null;
        let lazyLoadingImpl = null;
        // there isn't a native implementation already on the global
        // create a Proxy which is used to lazy load implementations
        const pluginProxy = (Plugins[pluginName] = new Proxy({}, {
            get(_, prop) {
                // proxy getter for any call on this plugin object
                const platform = getPlatform();
                const pltImplementation = impls[platform];
                if (pltImplementation) {
                    // this platform has an implementation we can use
                    if (!loadedImpl && !lazyLoadingImpl) {
                        // haven't loaded the implementation yet
                        if (typeof pltImplementation === 'function') {
                            // fn provided to load the implementation
                            const loaderRtn = pltImplementation();
                            if (loaderRtn) {
                                // received an object from the implementation loader fn
                                if (typeof loaderRtn.then === 'function') {
                                    // returned a promise to lazy load the implementation
                                    lazyLoadingImpl = loaderRtn;
                                }
                                else {
                                    // return the data we need
                                    loadedImpl = loaderRtn;
                                }
                            }
                        }
                        else {
                            // given the exact value already
                            loadedImpl = pltImplementation;
                        }
                    }
                    if (loadedImpl) {
                        // implementation loaded and has the methd to call ready
                        const func = Reflect.get(loadedImpl, prop);
                        if (typeof func === 'function') {
                            return (...args) => Reflect.apply(func, loadedImpl, args);
                        }
                        throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, exports.ExceptionCode.Unimplemented);
                    }
                    if (lazyLoadingImpl) {
                        // actively lazy loading the implementation
                        if (prop === 'addListener') {
                            // Plugin.addListener()
                            // returns an object with a remove() fn
                            return (...args) => {
                                // doing some lazy loading trickery so we can return
                                // an object, yet still lazy load the implementation
                                let loadedRtn = null;
                                lazyLoadingImpl.then(lazyLoadedImpl => {
                                    loadedImpl = lazyLoadedImpl;
                                    const func = Reflect.get(loadedImpl, prop);
                                    loadedRtn = Reflect.apply(func, loadedImpl, args);
                                });
                                return {
                                    remove: () => {
                                        lazyLoadingImpl.then(lazyLoadedImpl => {
                                            loadedImpl = lazyLoadedImpl;
                                            if (loadedRtn) {
                                                loadedRtn.remove();
                                            }
                                        });
                                    },
                                };
                            };
                        }
                        if (prop === 'removeAllListeners') {
                            // Plugin.removeAllListeners()
                            // returns void, not a promise
                            return () => {
                                lazyLoadingImpl.then(lazyLoadedImpl => {
                                    loadedImpl = lazyLoadedImpl;
                                    const func = Reflect.get(loadedImpl, prop);
                                    return Reflect.apply(func, loadedImpl, []);
                                });
                            };
                        }
                        return (...args) => {
                            return lazyLoadingImpl.then(lazyLoadedImpl => {
                                // implementation is now loaded and has the methd to call ready
                                loadedImpl = lazyLoadedImpl;
                                const func = Reflect.get(loadedImpl, prop);
                                if (typeof func === 'function') {
                                    return Reflect.apply(func, loadedImpl, args);
                                }
                                throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, exports.ExceptionCode.Unimplemented);
                            });
                        };
                    }
                }
                throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, exports.ExceptionCode.Unimplemented);
            },
        }));
        registeredPlugins.set(pluginName, pluginProxy);
        return pluginProxy;
    };
    // convert all the existing plugins on the global Capacitor.Plugins
    // object into proxies automatically
    Object.keys(Plugins).forEach(pluginName => registerPlugin(pluginName));
    cap.convertFileSrc = convertFileSrc;
    cap.getPlatform = getPlatform;
    cap.getServerUrl = () => webviewServerUrl;
    cap.handleError = handleError;
    cap.isNativePlatform = isNativePlatform;
    cap.isPluginAvailable = isPluginAvailable;
    cap.logJs = logJs;
    cap.pluginMethodNoop = pluginMethodNoop;
    cap.registerPlugin = registerPlugin;
    cap.Exception = CapacitorException;
    cap.DEBUG = !!cap.DEBUG;
    initBridge(win, cap);
    initEvents(win, cap);
    initVendor(win, cap);
    initLegacyHandlers(win, cap);
    return cap;
};
const initCapacitorGlobal = (win) => (win.Capacitor = createCapacitor(win));

const Capacitor = /*#__PURE__*/ initCapacitorGlobal((typeof globalThis !== 'undefined'
    ? globalThis
    : typeof self !== 'undefined'
        ? self
        : typeof window !== 'undefined'
            ? window
            : typeof global !== 'undefined'
                ? global
                : {}));
const registerPlugin = Capacitor.registerPlugin;
/**
 * @deprecated Provided for backwards compatibility for Capacitor v2 plugins.
 * Capacitor v3 plugins should import the plugin directly. This "Plugins"
 * export is deprecated in v3, and will be removed in v4.
 */
const Plugins = Capacitor.Plugins;
/**
 * Provided for backwards compatibility. Use the registerPlugin() API
 * instead, and provide the web plugin as the "web" implmenetation.
 * For example
 *
 * export const Example = registerPlugin('Example', {
 *   web: () => import('./web').then(m => new m.Example())
 * })
 *
 * @deprecated Deprecated in v3, will be removed from v4.
 */
const registerWebPlugin = (plugin) => legacyRegisterWebPlugin(Capacitor, plugin);

/**
 * Base class web plugins should extend.
 */
class WebPlugin {
    constructor(config) {
        this.loaded = false;
        this.listeners = {};
        this.windowListeners = {};
        if (config) {
            // TODO: add link to upgrade guide
            console.warn(`Capacitor WebPlugin "${config.name}" config object was deprecated in v3 and will be removed in v4.`);
            this.config = config;
        }
    }
    unimplemented(msg = 'not implemented') {
        return new Capacitor.Exception(msg, exports.ExceptionCode.Unimplemented);
    }
    unavailable(msg = 'not available') {
        return new Capacitor.Exception(msg, exports.ExceptionCode.Unavailable);
    }
    addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
    }
    removeWindowListener(handle) {
        if (!handle) {
            return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
    }
    addListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(listenerFunc);
        // If we haven't added a window listener for this event and it requires one,
        // go ahead and add it
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
            this.addWindowListener(windowListener);
        }
        return {
            remove: () => {
                this.removeListener(eventName, listenerFunc);
            },
        };
    }
    removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
            return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        // If there are no more listeners for this type of event,
        // remove the window listener
        if (!this.listeners[eventName].length) {
            this.removeWindowListener(this.windowListeners[eventName]);
        }
    }
    removeAllListeners() {
        this.listeners = {};
        for (const listener in this.windowListeners) {
            this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
    }
    notifyListeners(eventName, data) {
        const listeners = this.listeners[eventName];
        if (listeners) {
            listeners.forEach(listener => listener(data));
        }
    }
    hasListeners(eventName) {
        return !!this.listeners[eventName].length;
    }
    registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
            registered: false,
            windowEventName,
            pluginEventName,
            handler: event => {
                this.notifyListeners(pluginEventName, event);
            },
        };
    }
    load() {
        this.loaded = true;
    }
}

const WebView = /*#__PURE__*/ registerPlugin('WebView');

exports.Capacitor = Capacitor;
exports.CapacitorException = CapacitorException;
exports.Plugins = Plugins;
exports.WebPlugin = WebPlugin;
exports.WebView = WebView;
exports.registerPlugin = registerPlugin;
exports.registerWebPlugin = registerWebPlugin;
//# sourceMappingURL=index.cjs.js.map
